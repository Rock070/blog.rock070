{"pages":[{"title":"about","text":"","link":"/blog.rock070/about/index.html"},{"title":"categories","text":"","link":"/blog.rock070/categories/index.html"}],"posts":[{"title":"CSS 設計模式研究筆記","text":"CSS 是一個好理解但不好使用跟維護的語言，所以衍生出非常多的理論跟方法，目的是為了提高程式碼在開發時的可讀性、維護性、模組化、效率 …等等 良好的 CSS 架構 預測 Predictable 複用 Reusable：樣式可以重複使用的，避免重複性高 維護 Maintainable：可讀性高，後續調整或加東西，不需要大幅調整架構 延展 Scalable：後續加東西，不需要大幅調整架構 一、物件導向 CSS：OOCSS By Nicole Sullivan兩大原則 Sperate Structure &amp; Skin - 分離結構與顏色 即將顏色樣式與大小樣式分離，針對元素中的顏色的樣式單獨抽出做分離，避免重複性高的 CSS。 123456789101112131415161718192021222324.box-1 { width: 200px; height: 200px; background-color: yellow; border: 1px solid black; box-shadow: rgba(0, 0, 0, 0.5) 2px 0px 2px;}.box-2 { width: 320px; height: 400px; overflow: hidden; background-color: yellow; border: 1px solid black; box-shadow: rgba(0, 0, 0, 0.5) 2px 0px 2px;};.button { width: 120px; height: 48px; background-color: yellow; border: 1px solid black; box-shadow: rgba(0, 0, 0, 0.5) 2px 0px 2px;} 12345678910111213141516171819202122.box-1 { width: 200px; height: 200px;}.box-2 { width: 320px; height: 400px; overflow: hidden; };.button { width: 120px; height: 48px;}.skin { background-color: yellow; border: 1px solid black; box-shadow: rgba(0, 0, 0, 0.5) 2px 0px 2px;} Sperate Container &amp; Content - 容器與內容分離 分離 html 與 css，盡量將可共用的 class 單獨分離出來，這樣好處是若有多處重複的樣式，可使用同一個 class。 範例：box 內有一個標題跟一個內文，標題內有一部分特殊樣式： 1234567891011.box-1 div { color: red;}.box-1 p { color: black;}.box-1 div span { color: green;} 1234567891011.title { color: red;}.content { color: black;}.green-text { color: green;} 簡單來說：使用 class 寫樣式，每個 class 又有不同用途，如大小、顏色等等 範例： &lt;button class=\"btn btn-primary btn-large\"&gt;&lt;/button&gt; btn: 按鈕的基本樣式btn-primary: 按鈕的顏色btn-large: 按鈕的大小 透過這樣分離的方式，來讓網頁樣式更便於管理、可讀性高、好維護的效果。 範例：Bootstrap。 二、SMACSS(Scalable and Modular Architecture for CSS)SMACSS 由 Jonathan Snook 提出 顧名思義就是可擴展與模組化的設計模式。 基本架構： 1. Base包含 reset CSS 與 HTML tag 常用的樣式設定。 你應該有聽過、甚至使用過 reset CSS，若不知道是什麼的話，我來解釋一下，由於瀏覽器預設會有一些 CSS 樣式（例如：間距），所以為了確保畫面樣式的一致性及達到設計需求，通常我們在 CSS 最前面放上 reset CSS，把一些 padding、margin 給清空。 而 Base 的觀念裡面，除了 reset CSS，前端還要去思考哪些 HTML Tag 會經常用到樣式的設定，並直接在此處就加上 CSS。 12345678910111213141516# reset cssbody, html { padding: 0, margin: 0,}# html tag 常用設定input { outline: none;}a:focus { text-decoration: none;} 2. Layout每頁都會出現的元素（主要組件）：header、footer 通常會使用 ID 選擇器，如： 123456789#header, #article, #footer { width: 960px; height: auto;}#article { border: solid #CCC; border-width: 1px 0 0;} 3. Module兩頁以上會出現的元素（次要組件）：form、navigation item 之類的 避免使用 ID 和元素選擇器，只使用 class，每個組件內可能都會有個別的元素 當元素內只有一個 span 的時候，這樣使用起來是沒有問題的： 12345678910&lt;div class=\"fld\"&gt; &lt;span&gt;Folder Name&lt;/span&gt;&lt;/div&gt;&lt;style&gt;.fld span { padding-left: 20px; background: url(icon.png);}&lt;/style&gt; 但當 span 增加並需要另外的樣式時，就可能會需要同時修改 CSS 跟 html 的架構，具有較低的維護性，所以作者推薦這樣的寫法，向元素增加 class，提高了元素樣式的語意，更清楚知道當中的區別 123456789101112131415161718192021222324&lt;div class=\"fld\"&gt; &lt;span class=\"fld-name\"&gt;Folder Name&lt;/span&gt; &lt;span class=\"fld-items\"&gt;(32 items)&lt;/span&gt; &lt;span class=\"fld-items\"&gt;(32 items)&lt;/span&gt;&lt;/div&gt;&lt;style&gt;.fld { padding-left: 20px; background: url(icon.png);}.fld-name { font-size: 24px; color: orange;}.fld-item { font-size: 14px; color: green;}&lt;/style&gt; 4. State元素的狀態 可使用 is 前綴符 使用 JavaScript DOM 事件來為元素加上 class 允許使用 !important，因為作者認為一個元素同時不會存在兩個狀態。 例如點擊下拉選單後，選項欄位要延展出來變成 active 狀態，以下已重點樣式描述， 123456.options { display: none}.is-options-active { display: block !important} 5. Theme根據不同主題單獨抽離樣式的設計方法，以下範例可以看到，有三個 css 檔案， all.css：主要管理主題間共同的樣式theme-morning.css： 定義 morning 主題的樣式theme-night.css： 定義 night 主題的樣式 此架構可以讓主題可以切開來，按照需求引入主題檔案 morning 主題：引入 all.css 與 theme-morning.cssnight 主題：引入 all.css 與 theme-night.css 123456789101112131415161718### all.css.mod { border: solid 1px }### theme-morning.css.mod { border-color: white}### theme-night.css.mod { border-color: black} 三、BEMBlock(區塊)-Element（元素）-Modifier（修飾子） 12345&lt;ul class=\"menu\"&gt; &lt;li class=\"item\"&gt;&lt;/li&gt; &lt;li class=\"item active\"&gt;&lt;/li&gt; &lt;li class=\"item\"&gt;&lt;/li&gt;&lt;/ul&gt; 12345&lt;ul class=\"menu\"&gt; &lt;li class=\"menu__item\"&gt;&lt;/li&gt; &lt;li class=\"menu__item menu__item--active\"&gt;&lt;/li&gt; &lt;li class=\"menu__item\"&gt;&lt;/li&gt;&lt;/ul&gt; Element 使用雙底線做分隔，Modifier 使用雙 dash 做分隔。 menu 是區塊，menu__item 是 menu 的元素，active 是 menu__item 的一種狀態。 四、CSS in JS隨著前端框架的出現，前端的開發逐漸 component 化，一個頁面的個別元素可以切分 component 圖片來源：六角學院 例如在 Vue 中，一個元件一個檔案，將一個元件的樣式、事件、結構都封裝在 .vue 檔中內，這樣的格式可以達到 HTML、CSS、JS 分離的寫法，並非網頁的標準格式，所以還會需要通過 Vue-cli 中的 vue-loader 來做編譯，所以這樣的寫法是屬於 CSS in JS 的一種，只是透過 Vue 提供的語法糖變成這樣的架構。 1234567891011121314151617181920212223242526&lt;template&gt;&lt;div @click=\"clickHandler\"&gt; {{ message }} &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { setup () { const message = 'Hello Vue' const clickHandler = () =&gt; { alert('good!!') } return { message, clickHandler } } }&lt;/script&gt;&lt;style scope&gt;div { color: red; font-size: 24px;}&lt;/style&gt; 特別講一下，style 中的 scope 代表 Vue 會對該元件生成一個隨機的屬性（Attribute），透過 CSS Attribute selector 的方式來做到 CSS 的切分，這樣在不同的元件中的 div 樣式就不會互相干擾囉 styled-component（CSS in JS Library）React 社群推出的 styled-component，將 CSS 寫在 component 內，達到 CSS in JS 的作用，可以很直接的接收元件的 props 來控制 CSS，透過這樣的方式可以做到讓 CSS 狀態控制變得更彈性。 1234567891011121314151617const Button = styled.button` background: ${props =&gt; props.primary ? \"palevioletred\" : \"white\"}; color: ${props =&gt; props.primary ? \"white\" : \"palevioletred\"}; font-size: 1em; margin: 1em; padding: 0.25em 1em; border: 2px solid palevioletred; border-radius: 3px;`;render( &lt;div&gt; &lt;Button&gt;Normal&lt;/Button&gt; &lt;Button primary&gt;Primary&lt;/Button&gt; &lt;/div&gt;); 優點： 單一元件的樣式、結構、邏輯，都寫在一個檔案內，比起舊式寫法（HTML、JS、CSS 檔案切開）好管理，若其他專案需要使用，元件也方便單獨切割。 維護時不需另外去找對應的樣式檔案。 html 與 css 命名合在一起，不必去彼此對照。 缺點： 元件切換主視覺需要重新寫一個 &lt;ThemeComponent /&gt;，因為若要使用單一元件，樣式差異很大的情況，透過 props 控制會變得很麻煩 用字串的方式寫入樣式，少了 CSS 的 auto complete、編輯器提供的顏色 要達到共用樣式必須將元件切小，才會有一定的共用度 五、原子化樣式（Atomic CSS）Atomic CSS 由 Thierry Koblentz (Yahoo!)在 2013 年挑戰 CSS 最佳實踐中首次使用，將樣式的名稱指向每個單獨的 class ，並把名稱縮小化，將結構 html 與樣式 css 結合，當按鈕的樣式需要修改的時候，我們修改的是 HTML 而不是 CSS。 1&lt;div class=\"bw-2x bss p-1x\"&gt; 這是原子 CSS 範例 &lt;/div&gt; 12345678910111213141516171819/* 原子 CSS *//* Atomic CSS */.bw-2x { border-width: 2px;}.bss { border-style: solid;}.sans { font-style: sans-serif;}.p-1x { padding: 10px;}/* Not atomic, because the class contains 2 rules */.p-1x-sans { padding: 10px; font-style: sans-serif;} 但會衍伸出的問題是，沒有一個命名的約定，若每個專案的命名者不同，那當你加入一個新專案的時候，就必須重新學習該專案的 class 命名方式，例如 A 專案對於 border-width: 2px 的命名是 bw-2，B 專案的命名是 b-2，這樣專案一多起來，使用上就會帶來大大的不便。 後來誕生的 CSS 框架 tailwindcss 提出了一個命名規範，並可以自行擴充樣式。 圖片源自 tailwindcss.com 圖片源自 tailwindcss.com Tailwindcss 優缺點比較優點 不需要去想 CSS 命名 CSS 樣式的量通常不會變多，因為很少在撰寫 CSS 檔案了，共用性高 修改樣式只需要修改 HTML 沒有使用到的 CSS 將會在生產環境編譯時清除，達到輕巧化 缺點 需要學習一個既定的命名約定 HTML 會變得更加龐大 六、寫在 JS 中的原子樣式（Atomic CSS in JS ）待更新 推薦文章：Atomic-css-in-js 延伸閱讀：Atomic CSS 優化樣式開發 參考來源：CSS 的模組化方法：OOCSS、SMACSS、BEM、CSS Modules、CSS in JS 從 Vue 來看 CSS 管理方案的發展 SMACSS 教學 Sass教學 (30) - SMACSS - State Rules Day5. CSS 設計模式(一) - SMACSS","link":"/blog.rock070/2021/10/07/css-pattern/"},{"title":"學習動機與目標","text":"先說一下我的背景我讀的科系跟軟體知識完全沒有關係，是大四下對軟體開發有興趣，學了之後就奮不顧身的踏進了網頁開發的領域。 目前是資歷一年的前端工程師，工作之後在切版都沒有什麼問題，邏輯的設計上都可以應付，但總覺得自己寫出的程式碼與資深同事寫出來的總是有落差，研究了一陣子演算法之後，發現對自己的開發的邏輯跟思考脈絡有很大的幫助，所以決定開始一系列的學習，也希望自己可以朝成為資深工程師的路更前進一步。 接下來會寫一系列的演算法與資料結構相關系列筆記跟心得，也會搭配一些 LeetCode 的題目，脈絡會根據下方參考資料中綜合出一個版本。 學習目標與文章架構（待邊寫邊更新） 什麼是 Big O 演算法 六種排序（bubble、insertion、selection、merge、heap、quick） 搜尋（Linear、binary） 遞迴(recursion) Dynamic Programming Greedy 資料結構 B Linked List B Doubly Linked List B Queue B Stack B Hash Table B Heap - max and min heap versions B Priority Queue A Trie A Tree A Binary Search Tree A AVL Tree A Red-Black Tree A Graph (both directed and undirected) A Bloom Filter javascript 演算法與資料結構路線圖與參考文章 trekhleb/javascript-algorithms sisterAn/JavaScript-Algorithms 資料結構與演算法 (JavaScript) - Udemy 前端工程師用 javaScript 學演算法 - hannahpun 第 11 屆 iThome 鐵人賽","link":"/blog.rock070/2022/04/19/algorithms-1/"},{"title":"Linked List(連結串列)","text":"Linked List 連結串列，是資料結構中是常見、基本的資料型態，由 Node(節點）組成，每個節點各自儲存在非連續的記憶體位址，並透過 Pointer(指標) 來紀錄下一個節點的位址，最後一個節點的 pointer 指向 Null。 Linked List 有兩項屬性： length(連結長度) head(第一個 Node 位址) Node 有兩項屬性： value Pointer（下一個 Node 的位址，最後一個 Node 指向 null） 從下圖可以看到每一個 Node 都指向下一個 Node 位址，最後一個指向 Null。 用 JavaScript 實作一個 Linked List完整程式碼 - GitHub，可以先 clone 下來，或是跟著下面一步一步建立函式。 本來想用 class 來實作，但最近看了這一篇關於為什麼不應該在 JS 中使用 class 的文章（stop-writing-classes-in-javascript） ，所以下面就直接使用函式來實作。 先定義一個 Node，擁有 value 與 next(等於 Pointer，指向下一個 Node) 屬性 123456const Node = (value) =&gt; { return { value, next: null }} 再來定義一個 Linked List，擁有 length(連結長度) 與 head（指向第一個 Node）屬性 123456789const LinkedList = () =&gt; { let head = null let length = 0 return { head, length, }} 接下來我們會在 LinkedList 這個函式內建立一些方法，有些方法，類似於 JS 中 Array.prototype 提供的方法： 12345678pushpopprintAllshiftgetunshiftinsertAtremoveAt Push在連結的結尾加上一個 Node 12345678910111213141516const push = (value) =&gt; { // 建立一個 Node let newNode = Node(value) // 當連結內沒有 Node 的時候，指定新的 Node 為第一個 Node if (head === null) head = newNode // 當連結內已經有 Node 的時候，把最後一個 Node 的 next 指定為新的 Node else { let currentNode = head while (currentNode.next !== null) { currentNode = currentNode.next } currentNode.next = newNode } // 連結長度 +1 length++} Pop把最後一個 Node 排除 1234567891011121314151617181920const pop = () =&gt; { // 當 Linked List 沒有 Node 的時候返回 null if (head === null) return null // 當 linked List 長度為 1 的時候把 head 跟 length 調整為初始化 if (length === 1) { let node = head head = null length = 0 return node } // 把倒數第二個 Node 的 next 改成 null，並把 Linked List 的長度 - 1 let currentNode = head while (currentNode.next.next !== null) { currentNode = currentNode.next } let popNode = currentNode.next currentNode.next = null length-- return popNode } printAll印出 Linked List 內所有的值 12345678910111213const printAll = () =&gt; { // 沒有節點則印出 nothing if (head === null) { console.log('Nothing in this linked list') return } // 遍歷所有節點 let currentNode = head while (currentNode !== null) { console.log(currentNode.value) currentNode = currentNode.next }} shift將 Linked List 的第一個節點移除，只需要將 Linked List 的 Head 改成第二個節點就可以了。 1234567891011121314const shift = () =&gt; { // 若沒有節點則回傳 null if (head === null) return null // 若節點只有一個，就把 linkedList 初始化 if (length === 1) { let node = head head = null length = 0 return node } // 若不止一個節點，則把 head 變成第二個節點開始，並長度 - 1 head = head.next length--} get根據 index 來找值，與 array 不同的是，需要從第一個節點開始找，直到找到 index 指定的節點 12345678910111213const get = (index) =&gt; { // 若 index 大於 Linked List 長度或小於 0 則回傳 null if (index &gt; length || index &lt; 0) return null // 若只有一個節點，則回傳第一個節點的值 if (head === null) return head.value // 若不止一個節點則進入迴圈開始尋找 let currentNode = head // 從 i = 1 開始是因為上一行已經指定第一個節點了 for (let i = 1; i &lt;= index; i++) { currentNode = currentNode.next } return currentNode.value} unshift在 head 前新增一個節點，並指定新節點為 head 123456789const unshift = (value) =&gt; { // 建立新節點 let newNode = Node(value) // 若已經有至少一個節點，則將新節點的 next 指向原本的 head if (head !== null) newNode.next = head head = newNode length++ return newNode} insertAt在某個 index 插入一個節點 12345678910111213141516171819202122232425const insertAt = (index, value) =&gt; { // 若 index 大於長度或小於 0 則返回 null if (index &gt; length || index &lt; 0) return null // 若 index = 0 或是原本就沒有節點，則使用上方寫過的 unshift 來新增 if (index === 0 || head === null) { unshift(value) return true } // 若 index 剛好等於串列的長度，則使用上方寫過的 push 來新增 if (index === length) { push(value) return true } // 若都沒有上述情況，使用遍歷的方式找到 index 的節點，將前一個節點的 next 指向新節點，並將新節點的 next 指向原本的該 index 的節點 let prevNode for (let i = 0; i &lt; index; i++) { if (i === 0) prevNode = head else prevNode = prevNode.next } const newNode = Node(value) newNode.next = prevNode.next prevNode.next = newNode length++ return true} removeAt刪除某個 index 的節點，邏輯跟 insertAt 很像，但是方法改使用 pop &amp; shift。 1234567891011121314151617181920const removeAt = (index) =&gt; { if (index &gt; length || index &lt; 0) return null if (index === 0 || head === null) return shift() if (index === length) return pop() let prevNode let nextNode let value // 使用遍歷的方式找到該節點，並結把前一個節點的 next 指向原節點的下一個節點 for (let i = 0; i &lt; index; i++) { if (i === 0) prevNode = head else prevNode = prevNode.next } // 要移除的 node 的 value value = prevNode.next.value nextNode = prevNode.next.next prevNode.next = nextNode length-- return value} Linked List 與 Array 的比較Big O Array Linked List 存取資料 O(1) O(n) 插入與刪除第一筆資料 O(n) O(1) 插入與刪除最後一筆資料 O(1) O(n) 插入與刪除中間值的資料 O(n) O(n) Linked List特性 沒有 index 每個節點連結是透過 “next” 指標 優點 新增刪除資料較快，因為不需要調整 index 資料數量是動態的，不像 Array 有 resize 的問題。 缺點 因為沒有 index，所以在查找特定 node 的時候，需要從連結的頭開始找，時間複雜度為 O(N) 比 Array 使用更多的記憶體空間，因為每一個 node 都需要額外的空間來存儲存 pointer 儲存在記憶體的位址並不連續，需要到各個 node 位址去存取，相對 Array 連續的位址會更花時間。 因為單向性的關係，要反向存取是非常麻煩的。 適用時機 無法預期資料數量的時候，因為不用 resize 需要頻繁地進行新增或刪除的動作 不需要快速查詢資料 Array特性 有 index 優點 可以快速的存取任意的 index 元素，時間複雜度為 O(1)。 不需存 pointer 紀錄，較省記憶體空間 缺點 插入與刪除的方法是較花時間的，以 shift 為例，刪掉第一個元素之後，陣列中所有的元素的 index 都需調整 適用時機 希望可以快速存取資料 已知陣列大小 較少的記憶體空間使用 總結在 JavaScript 中實在想不到什麼情境會使用 Linked List，目前想到只有在大量的資料處理的時候會用的，若有其他的情境可以使用，請分享給我知道 XD leetcode 練習206. Reverse Linked List 參考文章 鏈結串列 Linked List - 第 11 屆 iThome 鐵人賽 Linked List: Intro(簡介)","link":"/blog.rock070/2022/04/20/linked-list/"},{"title":"Doubly Linked List（雙向連結串列）","text":"在 singly linked list 的基礎上，做一些變更： 每個節點都新增一個 prev 屬性，指向上一個節點，第一個節點的 prev 指向 null。 Linked List 屬性新增 tail 指向最後一個節點。 相對於 singly linked list 的優缺點優點 可以簡單地做到反向存取，從尾巴的節點開始取值 因為可以反向存去的關係，時間複雜度較 singly linked list 少一半 缺點 要花更多的記憶體空間","link":"/blog.rock070/2022/04/21/doubly-linked-list/"}],"tags":[],"categories":[{"name":"CSS Design","slug":"CSS-Design","link":"/blog.rock070/categories/CSS-Design/"},{"name":"JavaScript 演算法與資料結構","slug":"JavaScript-演算法與資料結構","link":"/blog.rock070/categories/JavaScript-%E6%BC%94%E7%AE%97%E6%B3%95%E8%88%87%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/"},{"name":"資料結構","slug":"資料結構","link":"/blog.rock070/categories/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B/"}]}