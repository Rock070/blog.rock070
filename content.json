{"pages":[{"title":"關於我","text":"我是 Rock070，這邊是我學習心得的紀錄與分享，透過紀錄自己學習的軌跡，希望可以給正在學習一樣領域的你一些參考與幫助，也同時可以幫助未來的我複習。 文章中若有錯誤請隨時留言跟我說！","link":"/blog.rock070/about/index.html"},{"title":"categories","text":"","link":"/blog.rock070/categories/index.html"}],"posts":[{"title":"CSS 設計模式研究筆記","text":"CSS 是一個好理解但不好使用跟維護的語言，所以衍生出非常多的理論跟方法，目的是為了提高程式碼在開發時的可讀性、維護性、模組化、效率 …等等 良好的 CSS 架構 預測 Predictable 複用 Reusable：樣式可以重複使用的，避免重複性高 維護 Maintainable：可讀性高，後續調整或加東西，不需要大幅調整架構 延展 Scalable：後續加東西，不需要大幅調整架構 一、物件導向 CSS：OOCSS By Nicole Sullivan兩大原則 Sperate Structure &amp; Skin - 分離結構與顏色 即將顏色樣式與大小樣式分離，針對元素中的顏色的樣式單獨抽出做分離，避免重複性高的 CSS。 123456789101112131415161718192021222324.box-1 { width: 200px; height: 200px; background-color: yellow; border: 1px solid black; box-shadow: rgba(0, 0, 0, 0.5) 2px 0px 2px;}.box-2 { width: 320px; height: 400px; overflow: hidden; background-color: yellow; border: 1px solid black; box-shadow: rgba(0, 0, 0, 0.5) 2px 0px 2px;};.button { width: 120px; height: 48px; background-color: yellow; border: 1px solid black; box-shadow: rgba(0, 0, 0, 0.5) 2px 0px 2px;} 12345678910111213141516171819202122.box-1 { width: 200px; height: 200px;}.box-2 { width: 320px; height: 400px; overflow: hidden; };.button { width: 120px; height: 48px;}.skin { background-color: yellow; border: 1px solid black; box-shadow: rgba(0, 0, 0, 0.5) 2px 0px 2px;} Sperate Container &amp; Content - 容器與內容分離 分離 html 與 css，盡量將可共用的 class 單獨分離出來，這樣好處是若有多處重複的樣式，可使用同一個 class。 範例：box 內有一個標題跟一個內文，標題內有一部分特殊樣式： 1234567891011.box-1 div { color: red;}.box-1 p { color: black;}.box-1 div span { color: green;} 1234567891011.title { color: red;}.content { color: black;}.green-text { color: green;} 簡單來說：使用 class 寫樣式，每個 class 又有不同用途，如大小、顏色等等 範例： &lt;button class=\"btn btn-primary btn-large\"&gt;&lt;/button&gt; btn: 按鈕的基本樣式btn-primary: 按鈕的顏色btn-large: 按鈕的大小 透過這樣分離的方式，來讓網頁樣式更便於管理、可讀性高、好維護的效果。 範例：Bootstrap。 二、SMACSS(Scalable and Modular Architecture for CSS)SMACSS 由 Jonathan Snook 提出 顧名思義就是可擴展與模組化的設計模式。 基本架構： 1. Base包含 reset CSS 與 HTML tag 常用的樣式設定。 你應該有聽過、甚至使用過 reset CSS，若不知道是什麼的話，我來解釋一下，由於瀏覽器預設會有一些 CSS 樣式（例如：間距），所以為了確保畫面樣式的一致性及達到設計需求，通常我們在 CSS 最前面放上 reset CSS，把一些 padding、margin 給清空。 而 Base 的觀念裡面，除了 reset CSS，前端還要去思考哪些 HTML Tag 會經常用到樣式的設定，並直接在此處就加上 CSS。 12345678910111213141516# reset cssbody, html { padding: 0,; margin: 0,}# html tag 常用設定input { outline: none;}a:focus { text-decoration: none;} 2. Layout每頁都會出現的元素（主要組件）：header、footer 通常會使用 ID 選擇器，如： 123456789#header, #article, #footer { width: 960px; height: auto;}#article { border: solid #CCC; border-width: 1px 0 0;} 3. Module兩頁以上會出現的元素（次要組件）：form、navigation item 之類的 避免使用 ID 和元素選擇器，只使用 class，每個組件內可能都會有個別的元素 當元素內只有一個 span 的時候，這樣使用起來是沒有問題的： 12345678910&lt;div class=\"fld\"&gt; &lt;span&gt;Folder Name&lt;/span&gt;&lt;/div&gt;&lt;style&gt;.fld span { padding-left: 20px; background: url(icon.png);}&lt;/style&gt; 但當 span 增加並需要另外的樣式時，就可能會需要同時修改 CSS 跟 html 的架構，具有較低的維護性，所以作者推薦這樣的寫法，向元素增加 class，提高了元素樣式的語意，更清楚知道當中的區別 123456789101112131415161718192021222324&lt;div class=\"fld\"&gt; &lt;span class=\"fld-name\"&gt;Folder Name&lt;/span&gt; &lt;span class=\"fld-items\"&gt;(32 items)&lt;/span&gt; &lt;span class=\"fld-items\"&gt;(32 items)&lt;/span&gt;&lt;/div&gt;&lt;style&gt;.fld { padding-left: 20px; background: url(icon.png);}.fld-name { font-size: 24px; color: orange;}.fld-item { font-size: 14px; color: green;}&lt;/style&gt; 4. State元素的狀態 可使用 is 前綴符 使用 JavaScript DOM 事件來為元素加上 class 允許使用 !important，因為作者認為一個元素同時不會存在兩個狀態。 例如點擊下拉選單後，選項欄位要延展出來變成 active 狀態，以下已重點樣式描述， 123456.options { display: none}.is-options-active { display: block !important} 5. Theme根據不同主題單獨抽離樣式的設計方法，以下範例可以看到，有三個 css 檔案， all.css：主要管理主題間共同的樣式theme-morning.css： 定義 morning 主題的樣式theme-night.css： 定義 night 主題的樣式 此架構可以讓主題可以切開來，按照需求引入主題檔案 morning 主題：引入 all.css 與 theme-morning.cssnight 主題：引入 all.css 與 theme-night.css 123456789101112131415161718### all.css.mod { border: solid 1px }### theme-morning.css.mod { border-color: white}### theme-night.css.mod { border-color: black} 三、BEMBlock(區塊)-Element（元素）-Modifier（修飾子） 12345&lt;ul class=\"menu\"&gt; &lt;li class=\"item\"&gt;&lt;/li&gt; &lt;li class=\"item active\"&gt;&lt;/li&gt; &lt;li class=\"item\"&gt;&lt;/li&gt;&lt;/ul&gt; 12345&lt;ul class=\"menu\"&gt; &lt;li class=\"menu__item\"&gt;&lt;/li&gt; &lt;li class=\"menu__item menu__item--active\"&gt;&lt;/li&gt; &lt;li class=\"menu__item\"&gt;&lt;/li&gt;&lt;/ul&gt; Element 使用雙底線做分隔，Modifier 使用雙 dash 做分隔。 menu 是區塊，menu__item 是 menu 的元素，active 是 menu__item 的一種狀態。 四、CSS in JS隨著前端框架的出現，前端的開發逐漸 component 化，一個頁面的個別元素可以切分 component 圖片來源：六角學院 例如在 Vue 中，一個元件一個檔案，將一個元件的樣式、事件、結構都封裝在 .vue 檔中內，這樣的格式可以達到 HTML、CSS、JS 分離的寫法，並非網頁的標準格式，所以還會需要通過 Vue-cli 中的 vue-loader 來做編譯，所以這樣的寫法是屬於 CSS in JS 的一種，只是透過 Vue 提供的語法糖變成這樣的架構。 1234567891011121314151617181920212223242526&lt;template&gt;&lt;div @click=\"clickHandler\"&gt; {{ message }} &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { setup () { const message = 'Hello Vue' const clickHandler = () =&gt; { alert('good!!') } return { message, clickHandler } } }&lt;/script&gt;&lt;style scope&gt;div { color: red; font-size: 24px;}&lt;/style&gt; 特別講一下，style 中的 scope 代表 Vue 會對該元件生成一個隨機的屬性（Attribute），透過 CSS Attribute selector 的方式來做到 CSS 的切分，這樣在不同的元件中的 div 樣式就不會互相干擾囉 styled-component（CSS in JS Library）React 社群推出的 styled-component，將 CSS 寫在 component 內，達到 CSS in JS 的作用，可以很直接的接收元件的 props 來控制 CSS，透過這樣的方式可以做到讓 CSS 狀態控制變得更彈性。 1234567891011121314151617const Button = styled.button` background: ${props =&gt; props.primary ? \"palevioletred\" : \"white\"}; color: ${props =&gt; props.primary ? \"white\" : \"palevioletred\"}; font-size: 1em; margin: 1em; padding: 0.25em 1em; border: 2px solid palevioletred; border-radius: 3px;`;render( &lt;div&gt; &lt;Button&gt;Normal&lt;/Button&gt; &lt;Button primary&gt;Primary&lt;/Button&gt; &lt;/div&gt;); 優點： 單一元件的樣式、結構、邏輯，都寫在一個檔案內，比起舊式寫法（HTML、JS、CSS 檔案切開）好管理，若其他專案需要使用，元件也方便單獨切割。 維護時不需另外去找對應的樣式檔案。 html 與 css 命名合在一起，不必去彼此對照。 缺點： 元件切換主視覺需要重新寫一個 &lt;ThemeComponent /&gt;，因為若要使用單一元件，樣式差異很大的情況，透過 props 控制會變得很麻煩 用字串的方式寫入樣式，少了 CSS 的 auto complete、編輯器提供的顏色 要達到共用樣式必須將元件切小，才會有一定的共用度 五、原子化樣式（Atomic CSS）Atomic CSS 由 Thierry Koblentz (Yahoo!)在 2013 年挑戰 CSS 最佳實踐中首次使用，將樣式的名稱指向每個單獨的 class ，並把名稱縮小化，將結構 html 與樣式 css 結合，當按鈕的樣式需要修改的時候，我們修改的是 HTML 而不是 CSS。 1&lt;div class=\"bw-2x bss p-1x\"&gt; 這是原子 CSS 範例 &lt;/div&gt; 12345678910111213141516171819/* 原子 CSS *//* Atomic CSS */.bw-2x { border-width: 2px;}.bss { border-style: solid;}.sans { font-style: sans-serif;}.p-1x { padding: 10px;}/* Not atomic, because the class contains 2 rules */.p-1x-sans { padding: 10px; font-style: sans-serif;} 但會衍伸出的問題是，沒有一個命名的約定，若每個專案的命名者不同，那當你加入一個新專案的時候，就必須重新學習該專案的 class 命名方式，例如 A 專案對於 border-width: 2px 的命名是 bw-2，B 專案的命名是 b-2，這樣專案一多起來，使用上就會帶來大大的不便。 後來誕生的 CSS 框架 tailwindcss 提出了一個命名規範，並可以自行擴充樣式。 圖片源自 tailwindcss.com 圖片源自 tailwindcss.com Tailwindcss 優缺點比較優點 不需要去想 CSS 命名 CSS 樣式的量通常不會變多，因為很少在撰寫 CSS 檔案了，共用性高 修改樣式只需要修改 HTML 沒有使用到的 CSS 將會在生產環境編譯時清除，達到輕巧化 缺點 需要學習一個既定的命名約定 HTML 會變得更加龐大 六、寫在 JS 中的原子樣式（Atomic CSS in JS ）待更新 推薦文章：Atomic-css-in-js 延伸閱讀Atomic CSS 優化樣式開發 參考來源CSS 的模組化方法：OOCSS、SMACSS、BEM、CSS Modules、CSS in JS 從 Vue 來看 CSS 管理方案的發展 SMACSS 教學 Sass教學 (30) - SMACSS - State Rules Day5. CSS 設計模式(一) - SMACSS","link":"/blog.rock070/2021/10/07/css-pattern/"},{"title":"學習動機與目標","text":"先說一下我的背景我讀的科系跟軟體知識完全沒有關係，是大四下對軟體開發有興趣，學了之後就奮不顧身的踏進了網頁開發的領域。 目前是資歷一年的前端工程師，工作之後在切版都沒有什麼問題，邏輯的設計上都可以應付，但總覺得自己寫出的程式碼與資深同事寫出來的總是有落差，研究了一陣子演算法之後，發現對自己的開發的邏輯跟思考脈絡有很大的幫助，所以決定開始一系列的學習，也希望自己可以朝成為資深工程師的路更前進一步。 接下來會寫一系列的演算法與資料結構相關系列筆記跟心得，也會搭配一些 LeetCode 的題目，脈絡會根據下方參考資料中綜合出一個版本。 動機 資料結構：就是把資料整理成最佳存取效率的結構 正如居家收納，好的收納方式可以讓物品井然有序，取用時方便又快速，反之，凌亂的收納方式，當想要找出想要的物品時，就得要大費周章。資料結構就是程式執行過程中，資料被收納的方式，同樣的一堆資料，用不同結構儲存，就會帶來不同的優缺點，進而左右資料存取的效率。 在成為資深工程師的路上，學習資料結構可以促進我解決能力的問題，使複雜的問題變得簡單，好處理。 學習目標與文章架構（待邊寫邊更新） 什麼是 Big O 演算法 六種排序（bubble、insertion、selection、merge、heap、quick） 搜尋（Linear、binary） 遞迴(recursion) Dynamic Programming Greedy 資料結構 B Linked List B Doubly Linked List B Queue B Stack B Hash Table B Heap - max and min heap versions B Priority Queue A Trie A Tree A Binary Search Tree A AVL Tree A Red-Black Tree A Graph (both directed and undirected) A Bloom Filter javascript 演算法與資料結構路線圖與參考文章 trekhleb/javascript-algorithms sisterAn/JavaScript-Algorithms 資料結構與演算法 (JavaScript) - Udemy 前端工程師用 javaScript 學演算法 - hannahpun 第 11 屆 iThome 鐵人賽","link":"/blog.rock070/2022/04/19/algorithms-motivation/"},{"title":"Linked List(連結串列)","text":"Linked List 連結串列，是資料結構中是常見、基本的資料型態，由 Node(節點）組成，每個節點各自儲存在非連續的記憶體位址，並透過 Pointer(指標) 來紀錄下一個節點的位址，最後一個節點的 pointer 指向 Null。 Linked List 有兩項屬性： length(連結長度) head(第一個 Node 位址) Node 有兩項屬性： value Pointer（下一個 Node 的位址，最後一個 Node 指向 null） 從下圖可以看到每一個 Node 都指向下一個 Node 位址，最後一個指向 Null。 用 JavaScript 實作一個 Linked List完整程式碼 - GitHub，可以先 clone 下來，或是跟著下面一步一步建立函式。 本來想用 class 來實作，但最近看了這一篇關於為什麼不應該在 JS 中使用 class 的文章（stop-writing-classes-in-javascript） ，所以下面就直接使用函式來實作。 先定義一個 Node，擁有 value 與 next(等於 Pointer，指向下一個 Node) 屬性 123456const Node = (value) =&gt; { return { value, next: null }} 再來定義一個 Linked List，擁有 length(連結長度) 與 head（指向第一個 Node）屬性 123456789const LinkedList = () =&gt; { let head = null let length = 0 return { head, length, }} 接下來我們會在 LinkedList 這個函式內建立一些方法，有些方法，類似於 JS 中 Array.prototype 提供的方法： 12345678pushpopprintAllshiftgetunshiftinsertAtremoveAt Push在連結的結尾加上一個 Node 12345678910111213141516const push = (value) =&gt; { // 建立一個 Node let newNode = Node(value) // 當連結內沒有 Node 的時候，指定新的 Node 為第一個 Node if (head === null) head = newNode // 當連結內已經有 Node 的時候，把最後一個 Node 的 next 指定為新的 Node else { let currentNode = head while (currentNode.next !== null) { currentNode = currentNode.next } currentNode.next = newNode } // 連結長度 +1 length++} Pop把最後一個 Node 排除 1234567891011121314151617181920const pop = () =&gt; { // 當 Linked List 沒有 Node 的時候返回 null if (head === null) return null // 當 linked List 長度為 1 的時候把 head 跟 length 調整為初始化 if (length === 1) { let node = head head = null length = 0 return node } // 把倒數第二個 Node 的 next 改成 null，並把 Linked List 的長度 - 1 let currentNode = head while (currentNode.next.next !== null) { currentNode = currentNode.next } let popNode = currentNode.next currentNode.next = null length-- return popNode } printAll印出 Linked List 內所有的值 12345678910111213const printAll = () =&gt; { // 沒有節點則印出 nothing if (head === null) { console.log('Nothing in this linked list') return } // 遍歷所有節點 let currentNode = head while (currentNode !== null) { console.log(currentNode.value) currentNode = currentNode.next }} shift將 Linked List 的第一個節點移除，只需要將 Linked List 的 Head 改成第二個節點就可以了。 1234567891011121314const shift = () =&gt; { // 若沒有節點則回傳 null if (head === null) return null // 若節點只有一個，就把 linkedList 初始化 if (length === 1) { let node = head head = null length = 0 return node } // 若不止一個節點，則把 head 變成第二個節點開始，並長度 - 1 head = head.next length--} get根據 index 來找值，與 array 不同的是，需要從第一個節點開始找，直到找到 index 指定的節點 12345678910111213const get = (index) =&gt; { // 若 index 大於 Linked List 長度或小於 0 則回傳 null if (index &gt; length || index &lt; 0) return null // 若只有一個節點，則回傳第一個節點的值 if (head === null) return head.value // 若不止一個節點則進入迴圈開始尋找 let currentNode = head // 從 i = 1 開始是因為上一行已經指定第一個節點了 for (let i = 1; i &lt;= index; i++) { currentNode = currentNode.next } return currentNode.value} unshift在 head 前新增一個節點，並指定新節點為 head 123456789const unshift = (value) =&gt; { // 建立新節點 let newNode = Node(value) // 若已經有至少一個節點，則將新節點的 next 指向原本的 head if (head !== null) newNode.next = head head = newNode length++ return newNode} insertAt在某個 index 插入一個節點 12345678910111213141516171819202122232425const insertAt = (index, value) =&gt; { // 若 index 大於長度或小於 0 則返回 null if (index &gt; length || index &lt; 0) return null // 若 index = 0 或是原本就沒有節點，則使用上方寫過的 unshift 來新增 if (index === 0 || head === null) { unshift(value) return true } // 若 index 剛好等於串列的長度，則使用上方寫過的 push 來新增 if (index === length) { push(value) return true } // 若都沒有上述情況，使用遍歷的方式找到 index 的節點，將前一個節點的 next 指向新節點，並將新節點的 next 指向原本的該 index 的節點 let prevNode for (let i = 0; i &lt; index; i++) { if (i === 0) prevNode = head else prevNode = prevNode.next } const newNode = Node(value) newNode.next = prevNode.next prevNode.next = newNode length++ return true} removeAt刪除某個 index 的節點，邏輯跟 insertAt 很像，但是方法改使用 pop &amp; shift。 1234567891011121314151617181920const removeAt = (index) =&gt; { if (index &gt; length || index &lt; 0) return null if (index === 0 || head === null) return shift() if (index === length) return pop() let prevNode let nextNode let value // 使用遍歷的方式找到該節點，並結把前一個節點的 next 指向原節點的下一個節點 for (let i = 0; i &lt; index; i++) { if (i === 0) prevNode = head else prevNode = prevNode.next } // 要移除的 node 的 value value = prevNode.next.value nextNode = prevNode.next.next prevNode.next = nextNode length-- return value} Linked List 與 Array 的比較Big O Array Linked List 存取資料 O(1) O(n) 插入與刪除第一筆資料 O(n) O(1) 插入與刪除最後一筆資料 O(1) O(n) 插入與刪除中間值的資料 O(n) O(n) Linked List特性 沒有 index 每個節點連結是透過 “next” 指標 優點 新增刪除資料較快，因為不需要調整 index 資料數量是動態的，不像 Array 有 resize 的問題。 缺點 因為沒有 index，所以在查找特定 node 的時候，需要從連結的頭開始找，時間複雜度為 O(N) 比 Array 使用更多的記憶體空間，因為每一個 node 都需要額外的空間來存儲存 pointer 儲存在記憶體的位址並不連續，需要到各個 node 位址去存取，相對 Array 連續的位址會更花時間。 因為單向性的關係，要反向存取是非常麻煩的。 適用時機 無法預期資料數量的時候，因為不用 resize 需要頻繁地進行新增或刪除的動作 不需要快速查詢資料 Array特性 有 index 優點 可以快速的存取任意的 index 元素，時間複雜度為 O(1)。 不需存 pointer 紀錄，較省記憶體空間 缺點 插入與刪除的方法是較花時間的，以 shift 為例，刪掉第一個元素之後，陣列中所有的元素的 index 都需調整 適用時機 希望可以快速存取資料 已知陣列大小 較少的記憶體空間使用 總結在 JavaScript 中實在想不到什麼情境會使用 Linked List，目前想到只有在大量的資料處理的時候會用的，若有其他的情境可以使用，請分享給我知道 XD leetcode 練習206. Reverse Linked List 141. Linked List Cycle 234. Palindrome Linked List 參考文章 鏈結串列 Linked List - 第 11 屆 iThome 鐵人賽 Linked List: Intro(簡介)","link":"/blog.rock070/2022/04/20/linked-list/"},{"title":"Doubly Linked List（雙向連結串列）","text":"在 singly linked list 的基礎上，做一些變更： 每個節點都新增一個 prev 屬性，指向上一個節點，第一個節點的 prev 指向 null。 Linked List 屬性新增 tail 指向最後一個節點。 相對於 singly linked list 的優缺點優點 可以簡單地做到反向存取，從尾巴的節點開始取值 因為可以反向存去的關係，時間複雜度較 singly linked list 少一半 缺點 要花更多的記憶體空間 leetcode 練習430. Flatten a Multilevel Doubly Linked List","link":"/blog.rock070/2022/04/21/doubly-linked-list/"},{"title":"Queue 列隊","text":"跟買電影票一樣，後來的人會排在隊伍後面，先買到票的人，會先離開。 特性 先進先出 FIFO(first in first out)，跟排隊買電影票的概念一樣。 元素沒有 index。 元素的新增只能從 queue 的後方。 元素的移除只能從 queue 的前方。 enqueue 意思是新增項目進 queue，dequeue 意思是移除 queue 內的項目。 使用 Linked List 實作 Stack在 Queue 的概念中，我們建立的 Linked List 只能使用 push, shift 方法，不能使用 shift, unshift, insertAt, removeAt。 要實作的方法：push：在隊伍後方新增元素shift：把隊伍前方的元素移除 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667const Node = (value) =&gt; { return { value, next: null }}const Queue = () =&gt; { let head = null let length = 0 // 在隊伍後方新增元素 const push = (value) =&gt; { let newNode = Node(value) if (head === null) head = newNode else { let currentNode = head while (currentNode.next !== null) { currentNode = currentNode.next } currentNode.next = newNode } length++ } // 把隊伍前方的元素移除 const shift = () =&gt; { if (head === null) return null if (length === 1) { let node = head head = null length = 0 return node } head = head.next length-- } const printAll = () =&gt; { if (head === null) { console.log('Nothing in this linked list') return } let currentNode = head while (currentNode !== null) { console.log(currentNode.value) currentNode = currentNode.next } } return { head, length, push, shift, printAll }}let myQueue = Queue()myQueue.push('Mike')myQueue.push('Harry')myQueue.push('James')myQueue.shift()myQueue.printAll() 印出結果：HarryJames Queue 觀念練習題以下會提供一系列的運算，請試著回答問題： 當題目的運算都結束後，queue 內還有幾個項目？ queue 的尾巴（tail）是什麼？ queue 的頭（head）是什麼？ 123456789enqueue pencilenqueue penenqueue staplerenqueue phonedequeue dequeue enqueue tabletenqueue notesdequeue 答案 最後 stack 會剩下三個元素 (tail) notes tablet phone (head) 1233 個notesphone LeetCode 練習題225. Implement Stack using Queues 補充：Dequeue 雙向佇列也可以寫作 deque，雙向佇列（doubled-ended queue），也是 statck 與 queue 的綜合體。 特性 前後都可以新增元素 前後都可以移除元素","link":"/blog.rock070/2022/04/21/queue/"},{"title":"Stack 堆疊","text":"Stack 堆疊 與 Queue 列隊 通常會放在一起講，兩種都是屬於抽象的資料類型，只是一種概念，在軟體工程中被廣泛運用。 可用任何方式實現 stack &amp; queue，如: 連結串列（Linked List）、陣列（Array）。 stack 堆疊像在堆石頭的一樣，只能從上方一直疊上去，要讓石頭變少，也是上方移除。 特性 後進先出 LIFO(Last in first out) 元素沒有 index 元素的新增與移除只能從 stack 的上方 使用 Linked List 實作 Stack如果不了解 Linked List 的，可以參考這一篇 Linked List(連結串列)。 在 Stack 的概念中，我們建立的 Linked List 只能使用 push, pop 方法，不能使用 shift, unshift, insertAt, removeAt。 要實作的方法：push： 在最上層新增元素pop： 把最上層的元素移除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172const Node = (value) =&gt; { return { value, next: null }}const Stack = () =&gt; { let head = null let length = 0 // 在最上層新增元素 const push = (value) =&gt; { let newNode = Node(value) if (head === null) head = newNode else { let currentNode = head while (currentNode.next !== null) { currentNode = currentNode.next } currentNode.next = newNode } length++ } // 把最上層的元素移除 const pop = () =&gt; { if (head === null) return null if (length === 1) { let node = head head = null length = 0 return node } let currentNode = head while (currentNode.next.next !== null) { currentNode = currentNode.next } let popNode = currentNode.next currentNode.next = null length-- return popNode } const printAll = () =&gt; { if (head === null) { console.log('Nothing in this linked list') return } let currentNode = head while (currentNode !== null) { console.log(currentNode.value) currentNode = currentNode.next } } return { head, length, push, pop, printAll }}let myStack = Stack()myStack.push('Mike')myStack.push('Harry')myStack.push('James')myStack.pop()myStack.printAll() 印出結果：MikeHarry Stack 觀念練習題以下會提供一系列的運算，請試著回答問題： 當運算都結束後，stack 內還有幾個項目？ stack 的最上方（top）是什麼？ 12345678push flourpush milkpush eggspop push leaveningpush sugarpoppop 答案 最後 stack 會剩下兩個元素 milk(top)flour 122 個milk LeetCoode 練習題20. Valid Parentheses 155. Min Stack 1047. Remove All Adjacent Duplicates In String","link":"/blog.rock070/2022/04/21/stack/"},{"title":"Hash Table（ㄧ）為什麼要有雜湊表？","text":"為什麼要有 Hash Table?先想一下，若有 10 幾筆資料，記錄了棒球員的編號、姓名與年薪。如果需要搜尋編號 100 的球員年薪，要如何做搜尋？ 一、線性搜索（sequentail search）：最簡單且最直接的就是把資料存進陣列裡，從索引 1 開始逐一搜尋，直到找到編號 100 的球員。這樣的做法可說是暴力，會花費的時間複雜度為 O(n)，但佔用較少的記憶體空間。 索引 姓名 編號 年薪（萬美金） 1 Ricky 38 50 2 Rock 4 90 3 Johnson 222 92 4 Jack 1 22 5 Rebacca 5 44 6 Tom 99 65 7 Nick 100 43 8 Jason 555 93 9 Peter 666 92 10 Lulu 49 67 11 Vincent 77 101 12 Peggy 333 42 13 George 664 26 二、使編號與索引相同：將資料整理成 Array 的格式，將編號與索引對在一起，如編號 99 就放在 索引 99 的位置。這個方法可以提高搜尋的速度，**時間複雜度：O(1)**，直接透過 index 就可以取得資料，如: Arr[100] 可得到編號 100 的球員資料。 但這樣，各個球員索引中間的空間也都被佔用了，會花費相當大的記憶體空間，如下方表格，雖然球員資料只有 13 筆，但卻佔用了 666 個空間。 索引 姓名 編號 年薪（萬美金） 1 Jack 1 22 ….. …… …… .. 4 Rock 4 90 5 Rebacca 5 44 ….. …… …… .. 38 Ricky 38 50 ….. …… …… .. 49 Lulu 49 67 ….. …… …… .. 77 Vincent 77 101 ….. …… …… .. 99 Tom 99 65 100 Nick 100 43 ….. …… …… .. 222 Johnson 222 92 ….. …… …… .. 333 Peggy 333 42 ….. …… …… .. 555 Jason 555 93 ….. …… …… .. 664 George 664 26 ….. …… …… .. 666 Peter 666 92 總結 Hash Table 兼顧快與節省空間。 上述的兩個方法，都會導致不如意的情況： 速度快，但記憶體佔用多 記憶體佔用少，但速度快 Hash Table 就是用來解決這個兩難的情況，他可以同時節省空間的佔用，也可以節省時間。","link":"/blog.rock070/2022/04/22/hash-table-1/"},{"title":"Hash Table（二）Hash Function 雜湊法？","text":"在講 hash table 之前，還必須先瞭解 hash function。簡單來說，hash funtion 就是把一個值換成另外一個值。 在 hash table 中，會把原始資料的 KEY（例如球員編號）經過 hash 過後，得到 index，把資料存在 hash table 相對應的 index 欄位中。 如：20 =&gt; !@!2∂∑œ–¡™¡ 特性 hash 的值是不可逆的，無法用 hash 值來推導出 hash 前的值。 不同的值經過 hash function 之後也可能會得到相同的 hash 值。 舉例假設有一個 hash function hashMethod，hash 過的值為 原始值 ÷ 6 的餘數： 123const hashMethod = (key) =&gt; { return key % 6} 將五個數字 [6, 12, 15, 18, 21]，經過 hash 之後會得到各自的 index [0, 0, 3, 0, 3]。 就可以形成 Hash Table： 123456[ [6, 12, 18], [], [], [15, 21],] 可以看到原始值都不一樣，但 hash 過後，卻出現重複的 0 跟 3，發生了很多衝突（collision），而且無法從 0 跟 3 來推出 hash 前的值是什麼。 衝突（Collision）：當 hashtable 內經過 hash 後的值，有至少兩個以上的值相同，就稱作衝突。 如何處理衝突：同一個 index 需要存放很多的 value，這時就需要以 array 的方式記錄，使 hash table 變成二維陣列，上面的例子即為二維陣列。 Hash Function 的應用世界上有成千上萬種 Hash Function，應用在不同的情境。 如資料庫存放的密碼，密碼存放到資料庫前，會先經過 Hash Function 處理，將你的密碼改成一串亂碼，如：123456 經過 hash function 處理變成 @dsop™£åß∂¡，這樣做的原因是： 對於資料庫管理員來說沒有辦法一眼就記下正確的密碼。 且發生資料外洩事件的時候，只要不知道 hash 的方式，駭客也無法存取你真正的密碼。 Hash Funtion 可以對搜尋球員資料的方法有什麼幫助呢？以上一篇文章中舉的例子來說，Array 中最大的球員編號為 666，代表需要使用 666 個空間，但實際球員只有 13 個。 這時候我們就可以透過 hash function 把球員編號都改成另一個值，一個縮小的值。例如：把最大的編號 666 改成 89，把編號 666 的 Peter 的年薪是 92 萬美元 的資料，存在陣列中索引 89 的地方，這樣陣列的長度就從 666 減少到 89，可以有效地減少使用空間，且同時擁有陣列快速搜尋的便利。 舉例幾個 Hash Function這邊介紹兩個基本的 hash function，但大部分的時候我們不需要深入研究 hash function 的實作方式，我們只需要在意：容不容易發生衝突、時間複雜度是多少這樣的特性，基本上只要看到前面就夠了，所以有興趣再看下去吧！ 補充：Load Factor Load Factor 是一個衡量 hash function 的一項指標。 m: 存放的元素數量n: hash table 的長度Load Factor = m / n Load Factor 的值越小，衝突的機率越低，越多未使用的空間。 Load Factor 的值越大，衝突的機率越大，越少未使用的空間。 0 &lt; Load Factor &lt; 1 一、Division Method 除法方法 index = Key % hashtable size 這個方法就跟前面提到的例子一樣，把 Key ÷ 雜湊表的長度，取餘數當作 index 存入 Array 中，這邊把 id 當作 Key。hash 後的值 會小於 hash table 的長度，並且大於 0。 10 &lt; hash 後的值 &lt; hash table 的長度 Division Method 除法方法範例假設有一個 hashtable 的長度為 6，使用 Division Method hash 後，把資料放進 hash table，這樣 hash table 會長怎樣？ 原始資料 名字 ID Mike 11424 Drake 4174 James 6253 Kevin 554 hash 後的值 名字 ID ÷ 6 的餘數 Mike 11424 0 Drake 4171 1 James 6253 1 Kevin 554 2 Hash Table12345678[ [{ name: 'Mike', ID: 11424 }], [{ name: 'Drake', ID: 4171 }, { name: 'James', ID: 6253 }], [[{ name: 'Kevin', ID: 554 }], [], [], [],] Division Method 的優缺點優點 速度快，時間複雜度為 O(1) 缺點 hash table 的大小需盡量遠離 2 的次方值，若選擇 2 的次方值，較容易發生衝突，以下為例，若選擇 8 為 hash table 的大小，就發生了很多的衝突： 12[10123, 123125, 5325, 6435, 1235, 12224, 42145].map(node =&gt; node % 8)[3, 5, 5, 3, 3, 0, 1] 二、Multiplication Method (乘法方法)12A = (√5 - 1) / 2m = hash table 的長度 公式 index = [m(keyA % 1)] 過程 12345- 先把 key * (√5 - 1) / 2- 再求 ÷ 1 的餘數，將會得到 0 ~ 1 的值- 再乘以 m 將會得到介於 0 ~ (m - 1)的值- Math.floor 去掉小數點- 得到 0 ~ (m - 1)的值 可以看到這個方法相對除法方法更複雜一些，雖然還是會有衝突，但衝突的機率較 division method 小。 Multiplication Method 除法方法範例假設有一個 hashtable 的長度為 6，使用 Multiplication Method hash 後，把資料放進 hash table，這樣 hash table 會長怎樣？ 原始資料 名字 ID Mike 11424 Drake 4174 James 6254 Kevin 554 Hash 後的值 名字 ID hash function（乘法方法） 後的 index Mike 11424 2 Drake 4171 4 James 6254 1 Kevin 554 2 原始碼12345678910const arr2 = [11424, 4171, 6254, 554]const A = (Math.sqrt(5) - 1) / 2arr2.map(node =&gt; { return Math.floor((node * A) % 1 * 6)})// [2, 4, 1, 2] Hash Table12345678[ [], [{ name: 'James', ID: 6253 }], [{ name: 'Drake', ID: 4171 }, { name: 'Kevin', ID: 554 }] [], [[{ name: 'Mike', ID: 11424 }], [],]","link":"/blog.rock070/2022/04/25/hash-table-2/"},{"title":"Hash Table（三）什麼是 Hash Table 雜湊表？","text":"當資料沒有數字可以當作索引，或是資料間當作索引的數字差距太大，導致 Array 過長，就可以透過某種 Hash function 把資料中某個 Key 雜湊為較小數字的索引，這樣就更容易儲存資料，也好存取。 Hash Table 是一個陣列，陣列中每個元素都是一個 bucket。 選出每筆資料都有的一個值當作 key（如姓名、編號），經過 hash 函式後可以得到索引，藉此知道資料要放在 Hash Table 中哪個 bucket 中。 若遍歷原始資料 hash 過後，得到重覆的索引，就稱作衝突，可以用 Array 或是 Linked List 的結構讓資料共存在 bucket 內。 公開的方法：set、get、delete 私有的方法：hash 時間複雜度 set：O(1) Delete: O(1) get: O(1)：能夠透過 hash function 直接找出該 key 對應的 bucket 參考十六分鐘略懂刷題面試","link":"/blog.rock070/2022/04/26/hash-table-4/"},{"title":"Hash Table（四）實作一個 Hash Table","text":"完整程式碼 - GitHub，可以先 clone 下來，或是跟著下面一步一步建立函式。 接下來我們會在 Hash Table 中建立幾個方法，讓我們可以 set and get。 12345678// 內部使用的 hash functionhash1hash2// 對外暴露的方法：設定、取得、印出set,get,printAll, 一、初始化 hash table 123456const hashTable = (size) =&gt; { // 建立一個 hash table 可以存資料 let table = []; // 先根據 hash table 的長度來將建立二維陣列，方便處理衝突的情況。 for (let i = 0; i &lt; size; i++) table.push([]);} 二、實作第一個 hash 方法：division method 1const hash1 = key =&gt; key % size 三、實作第二個 hash 方法：multiplication method 1234const hash2 = key =&gt; { A = (Math.sqrt(5) - 1) / 2 return Math.floor(size * ((key * A) % 1))} 四、set 將資料存進 hash table 需傳入 key 與 value，KEY 經過 hash 之後生成 index，把 value 存在 table[index] 中。 1234const set = (key, value) =&gt; { let index = hash2(key) table[index].push({key, value})} 五、get 取得值 先將傳入的 key 進行 hash 得到 index，搜尋 table[index]，得到該位置的陣列後，搜尋陣列中相同的 key 值，即可得到該 value。 123456const get = (key) =&gt; { let index = hash2(key); for (let i = 0; i &lt; table[index].length; i++) { if (table[index][i].key === key) return table[index][i] }} 六、印出 hash table 1const printAll = () =&gt; { console.log(table) } 執行程式碼 1234567891011121314// 建立一個長度為六的 hash tablelet myHashTable = hashTable(6)// 設定四筆資料myHashTable.set(11424, 'Mike')myHashTable.set(6254, \"James\");myHashTable.set(554, \"Kevin\");myHashTable.set(4174, \"Drake\");// 取得並印出 id 為 4174 的資料console.log(myHashTable.get(4174))// 印出 hash tablemyHashTable.printAll() output123456789{ key: 4174, value: 'Drake' }[ [], [ { key: 6254, value: 'James' } ], [ { key: 11424, value: 'Mike' }, { key: 554, value: 'Kevin' } ], [], [ { key: 4174, value: 'Drake' } ], []] 當 hash function 中的 Key 不是數字前面實作了簡單的 hash table，但實際中我們的 key 並不會都只是單純的數字，有各種形態，像是字串，如顏色表： 敘述 hex rgb white #FFFFFF rgb(255, 255, 255) red #FF0000 rgb(255, 0, 0) magenta #FF00FF rgb(255, 0, 255) 不知道大家在撰寫樣式的時候有沒有用過這種寫法：color: white，用敘述的方式讓顏色指定為白色，非常的方便，讓我們不需要去記 hex 的色票。 但瀏覽器是如何知道 color: white，是要將顏色指向 #FFFFFF的呢？ 想像一下瀏覽器在資料庫內存了一個 table 記錄對應的： 敘述、hex、rgb。 當我們使用 color: white 的語法，瀏覽器就會去撈資料庫的資料，找到相對應的 hex 是 #FFFFFF。 但是會遇到一個問題，之前都是使用 number 的型態當作 key 來進行 hash，如：id: 571 =&gt; id: 5，但在上面的情況中，沒有數字可以直接使用，那我們要用什麼當作 key 來進行 hash 呢？ 把字串轉換成數字 我們可以把字串先轉成數字再進行 set，可以採用各種不同的方法 1. 把字串的長度當成 key： 是最簡單的方法，但不是很好的做法因為很容易發生衝突。 2. 將字串轉為 ASCII 把字串個別轉成 ASCII 並且相加。 3. 任何你想得到的組合算法 調換字串的位置，ASCII、相乘、相加、相除 …等等。 實作第二個方法: 將字串轉為 ASCII完整程式碼 - GitHub 延續上一個 hash table 的程式碼，新增一個 parse 方法。 一、parse 把字串型態的 key 轉換成 ASCII 並相加 12345const parse = (str) =&gt; { let sum = 0; for (char of str) sum += char.charCodeAt(); return sum % size;}; 二、hash function 多判斷型別 若非數字型別則使用 parse 解析為數字，再進行 hash。 12345678const hash2 = (key) =&gt; { let parseKey; if (typeof key !== \"number\") parseKey = parse(key); else parseKey = key; A = (Math.sqrt(5) - 1) / 2; return Math.floor(size * ((parseKey * A) % 1));};","link":"/blog.rock070/2022/04/26/hash-table-3/"},{"title":"樹的走訪：寬度優先走訪（BFS）、深度優先走訪（DFS）","text":"走訪的意思是，從根節點開始，逐個走訪各個節點，不同的拜訪順序，在程式碼的實作有很大的落差。 依照走訪原則，可以分為兩種： 寬度優先走訪 Breadth-First Tree Traversal 深度優先走訪 Depth-First Tree Traversal(PreOrder, InOrder, PostOrder) 一、寬度優先走訪 Breadth-First Tree Traversal 寬度優先的概念其實很簡單，從根開始，同一層都先走訪完之後，再進入下一層：如圖：level 1 的 1 開始，走訪完後進入 level 2 走訪 2, 3，再進入 level 走訪 4, 5, 6, 7。 以上圖為例，這個樹狀圖有四層，分別為第一層: 2第二層: 7, 5第三層: 2, 10, 6, 9第四層: 5, 11, 4 走訪的順序就會是： [ 2, 7, 5, 2, 10, 6, 9, 2, 11, 4 ] 用 JavaScript 實作寬度優先走訪實作一個 BFTT 函式，input 為 Tree，output 為依照 寬度優先走訪 的順序組成 result 陣列。 有一個 Tree，每個節點都叫做 TreeNode，TreeNode 有兩個屬性 value 與 children，value 為數字，children 為 TreeNode 陣列或是 null。 Tree Node 型別12345/** * @typedef { Object } TreeNode * @property { number } value * @property { Array[TreeNode] | null } * / Tree123456789101112131415161718192021222324252627282930const tree = { value: 2, children: [ { value: 7, children: [ { value: 2, children: null }, { value: 10, children: null }, { value: 6, children: [ { value: 5, children: null }, { value: 11, children: null }, ], }, ], }, { value: 5, children: [ { value: 9, children: [ { value: 4, children: null } ], }, ], }, ],}; 思路一層層遍歷 children，存進 queue，然後依照 queue 的特性：先進先出，從 queue 內排序第一的開始處理，處理完則離開 queue。 完成程式碼 - GitHub 123456789101112131415161718192021222324252627const BFTT = root =&gt; { let result = [] let queue = [] queue.push(root) let traversal = (tree) =&gt; { result.push(tree.value) let subTree = tree.children if (subTree) { for (let i = 0; i &lt; subTree.length; i++) { queue.push(subTree[i]); } } } while (queue.length !== 0) { traversal(queue[0]); queue.shift() } return result}let result = BFTT(tree);console.log(result)// [2, 7, 5, 2, 10, 6, 9, 2, 11, 4]; 二、Depth-First Tree Traversal（深度優先走訪）深度優先走訪 根據每個 subTree 的走訪順序，又可以區分為三種：Pre-Order、In-Order、Post-Order。 1. Pre-Order先遇到的節點先處理。 順序：root, left, right 從圖片中可以看到從根節點 F 開始，藍色為走訪順序，若顯示紅色則為無法再走下去的情況，這時就會則回到上一層繼續走訪，直到沒辦法再繼續下去。 完整程式碼 - GitHub 實作方法：先遇到的節點先走訪，並採用遞迴方式，若有 left, right 節點則繼續遞迴。 123456789101112131415const preOrder = (root) =&gt; { let result = []; const traversal = (node) =&gt; { result.push(node.value); if (node.left) traversal(node.left) if (node.right) traversal(node.right); }; traversal(root); return result;};// PreOrder: [\"F\", \"B\", \"A\", \"D\", \"C\", \"E\", \"G\", \"I\", \"H\"] 2. In-Order 順序： left, root, right 從圖片中可以看到從根節點 F 開始，藍色為走訪順序，若該節點為目前最左邊的節點，則推入 Inorder 陣列中；若顯示紅色則為無法再走下去的情況，這時就會則繼續尋找最左邊的節點，直到沒辦法再繼續下去。 完整程式碼 - GitHub 實作方法：越左的節點先走訪，並採用遞迴方式，若有 left, right 節點則繼續遞迴。 12345678910111213const InOrder = root =&gt; { let result = []; const traversal = node =&gt; { if (node.left) traversal(node.left) result.push(node.value) if (node.right) traversal(node.right) } traversal(root) return result};// // [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\"]; 3. Post-Order 順序：left, root, right 從圖片中可以看到從根節點 F 開始，藍色為走訪順序，若該節點為目前最左邊的節點，則推入 Postorder 陣列中，若找不到最左節點，就會將右邊的節點推入；若顯示紅色則為無法再走下去的情況，這時就會則繼續尋找，直到沒辦法再繼續下去。 完整程式碼 - GitHub 實作方法：越左的節點先走訪，並採用遞迴方式，若有 left, right 節點則繼續遞迴。 123456789101112131415const PostOrder = (root) =&gt; { let queue = []; const traversal = (node) =&gt; { if (node.left) traversal(node.left); if (node.right) traversal(node.right); queue.push(node.value); }; traversal(root); return queue;};// ['A', 'C', 'E', 'D', 'B', 'H', 'I', 'G', 'F']","link":"/blog.rock070/2022/04/27/tree-traversal/"},{"title":"Tree 樹","text":"由一個或多個節點（node）組成，一個節點也可以稱作樹 樹必須有一個唯一的 root 根節點 根節點以下的節點集合稱作子樹（subtree） 由節點之間的有向連線(edges)組成 樹是一種不會循環的圖形 Tree 的應用 file system 檔案系統就是一種樹狀資料結構的應用，同樣可以適用於廣度優先搜尋法與深度優先搜尋法 下方有 food 根目錄跟 fruit、meat 子目錄與目錄內的 jpg 檔案 1234567food |--- fruit |--- apple.jpg |--- orange.jpg |--- meat |--- beef.jpg |--- pork.jpg 若採用 深度優先搜尋法，只要看到目錄就會進入。進入 food 這個根目錄後，看到 fruit 目錄後，會直接進入並看到 apple.jpg 與 orange.jpg。接著再回到上一層，進入 meat 目錄看到 beef.jpg 與 pork.jpg 若採用 廣度優先搜尋法，進入 food 這個根目錄後，會看完所有的目錄，所以會看到 fruit 目錄與 meat 目錄，再來進入 fruit 目錄內，看到 apple.jpg 與 orange.jpg 檔案。接著再回到上一層，進入 meat 目錄看到 beef.jpg 與 pork.jpg。 DOM (Document Object Model) 有接觸過網頁前端開發的人應該都有看過這個模型，是由 W3C 提出的瀏覽器的標準化模型，目前主流的瀏覽器皆已按照此模型設計。 Binary Tree定義： 每一個節點最多只有兩個節點，具有方向性，稱作左節點、右節點。 符合樹的特性，但根節點必須至少擁有一個左子樹與右子樹。Binary Tree 的形容詞 full binary tree ：除了樹葉以外，每個節點都有兩個小孩。 complete binary tree ：各層節點全滿，除了最後一層，最後一層節點全部靠左。 perfect binary tree ：各層節點全滿。同時也是 full binary tree 和 complete binary tree 。 N-ary Tree 多元樹表示法「多元樹」。分 N 岔的樹，每個節點可以有零個、一個、兩個、 …… 、 N 個小孩。 注意到：多元樹，節點只有一個小孩時，沒有左小孩、右小孩的差別；二元樹，節點只有一個小孩時，有左小孩、右小孩的差別。 Left child-Right sibling representation 左兒子-右兄弟表示法每個節點中都只有一個最靠左的子節點，以及一個最靠近它的右兄弟。 多元樹重新表示成「左兒子右兄弟」：多元樹的左小孩，是「左兒子右兄弟」的左小孩；多元樹的其餘小孩（左小孩的兄弟），是「左兒子右兄弟」的右小孩、右右小孩、 …… 。 然後將樹往順時針轉 45 度，即為二元樹。 芸芸多元樹，皆得簡化成二元樹；區區二元樹，便可描述出多元樹。 樹的 Big O參考文章 深度優先搜尋(DFS)和廣度優先搜尋(BFS)演算法，實用的節點搜尋法 Binary Tree - 演算法筆記 樹的定義與基本術語","link":"/blog.rock070/2022/04/27/tree/"},{"title":"如何切換 Git 遠端分支","text":"檢查對應的遠端分支git branch -vv 123456git branch -vv* develop 5c22fb6 [origin/develop] docs(README): 新增分支介紹 main bc952a8 [origin/main: ahead 4, behind 13] deploy(END) 更換分支 方法一 git branch -u 遠端庫名/分支名 12345678910# 假設現在本地的 HEAD 在 developgit branch -u origin mainBranch 'develop' set up to track remote branch 'main' from 'origin'.git branch -vv * develop 5c22fb6 [origin/main: ahead 42, behind 13] docs(README): 新增分支介紹 main bc952a8 [origin/main: ahead 4, behind 13] deploy(END) [!NOTE] 什麼是 HEAD目前所在的分支。可參考：【冷知識】HEAD 是什麼東西？ 方法二 git push -u 遠端庫名/分支名 同時會把 commit 推向遠端 123456789101112# 假設現在本地的 HEAD 在 developgit branch -u origin mainBranch 'develop' set up to track remote branch 'main' from 'origin'.Everything up-to-dategit branch -vv * develop 5c22fb6 [origin/main: ahead 42, behind 13] docs(README): 新增分支介紹 main bc952a8 [origin/main: ahead 4, behind 13] deploy(END)","link":"/blog.rock070/2022/06/03/git-upstream/"},{"title":"建立可讀性高的 git 提交吧！","text":"在討論之前，我們應該先知道什麼是「可讀性低的提交」。 上方這個提交紀錄，可以四個提交大概看到提交的內容是什麼，但是又好像不太確定提交訊息所指的內容。「會員登入」這個提交，可以看出是跟會員登入有關係，但是然後呢？可能會有些疑問浮出心頭：「他是製作了會員登入的功能嗎？」、「修改了會員登入的樣式？」、「修正了會員登入的 bug？」、「還是重構了？」再看「調整會員登入」這個提交，「他修改了會員登入的什麼東西啊？」。 我相信在開發的過程中如果看到其他成員的提交訊息是這樣，心中可能會冒起這些疑問。如果還沒有冒出這些疑問，那讓我們看看下面的範例： 可以看到又有人提交了一個訊息叫做「會員登入」，跟第一個提交命名居然一樣，這時候團隊其他成員就生氣了：「這到底誰看得懂？」。 低可讀性造成什麼問題？ 無法一眼看出提交的主要內容 可能導致很多重複性的提交訊息 使合併提交的人，無法簡單的了解為什麼需要這個變更 這樣的提交訊息無論我們是要整理分支、cherry-pick、還是根據節點 code review，就會無法一眼就知道這個節點的修改內容，也因為這樣，整理起來就會變得困難。 高可讀性帶來什麼好處？讓我們再來看看下面這個提交： 跟剛剛相比，新增了以下幾點描述，使提交更清楚，「feat(會員登入): 登入功能與切版」可以很清楚知道，製作了「會員登入」頁面的「功能」與「切版」；「refactor(會員登入): 重構 useLogin 程式碼」可以清楚知道「重構」了「會員登入」頁面的 「useLogin」 函式。 如此，就能更清楚提交的內容了，而在不久的未來，可能會因為這樣貼心的舉動而感謝自己。另外，我們其實可以建立一套提交規範，讓團隊去遵守，更可以透過提交工具來簡單化這個過程。 建立一套提交規範規範可以根據團隊自己建立，就像感情一樣，沒有絕對好的，只有最適合的，最適合就是最好的。 目前被廣泛使用的就是 Angular 團隊使用的 Git Commit Guidelines ，也衍生了這一套規格： conventional commit ，目前我也是採用這一套。 接下來我會大概闡述一下這套規範，加上一些我個人的想法： 12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;body&gt;&lt;footer&gt; 每個提交都必須要有 header, body, footer，header 是由 type, scope, subject 所組成 而我們可以透過指令： git commit -m 'header' -m 'body' -m 'footer' 來達到這種提交訊息，如： 1git commit -am 'fix(全站): 修正 IOS 裝置頁面高度跑版問題' -m '因為用戶 在 IOS 裝置上收放 Toolbar 會導致頁面跑版，所以將 100vh 寫死更改為監聽 web resize 事件，每次 resize 都重新調整頁面高度 ' -m 'fix #22' git log 出來看看 123456789commit 88700ed8418fc8aa99c545cf5804fe3ba0d3c1b2 (HEAD -&gt; master)Author: rock070Date: Fri Jun 10 09:54:17 2022 +0800 fix(全站): 修正 IOS 裝置頁面高度跑版問題 因為用戶在 IOS 裝置上收放 Toolbar 會導致頁面跑版，所以將 100vh 寫死更改為監聽 web resize 事件，每次 resize 都重新調整頁面高度 fix #22 type 類型下面是可以選用的類型： 1234567891011feat: 新功能fix: 修正 bugdocs :文件內容修改style: 跟程式碼語意無關的修改，包含修改縮排、新增分號 ... 等等之類的refactor: 無關新功能與 bug 修正的程式碼修改perf: 程式碼對於提升效能有幫助的修改test: 新增或修改測試ci: 修改 ci 的配置檔chore: 無關 `src`, `test` 路徑內的檔案修改revert: 恢復某個提交build: 改變打包流程 Scope 範圍任何可以劃分程式碼改變的範圍，例如：page, router, compile, component … 等等。 Subject 主題對程式碼的修改做簡單的敘述 body 內文敘述這次程式碼變更的動機，並說明這個提交與改變前的對比。 若不知道怎麼寫，可以參考這三個問題： 為什麼這個提交是必要的？告訴審核 pull request 的人你的提交會帶來什麼改變，使他可以更簡單的辨認是否為不相干的提交。 它如何解決問題？ 這個提交對專案有什麼副作用？這個是很重要的，他可以有效地幫助你辨認，這個提交是否做太多改變了，如果一兩個副作用還可以接受，但如果是五、六個以上，就代表你做了太多了改變。 Footer 結尾結尾通常會有兩種： 標註 Breaking Change超級大更新，通常需要以 BREAKING CHANGE: 為開頭，或是在 header 前面加上 !，如 !feat(UI Library): 提供全新的 UI Library。 指出修正了什麼 issue，並關閉 issue，或是關閉了哪則 Pull Request。 另外可以到 GitHub 上看一些關注度較高的開源專案的提交訊息，例如：Linux 的 commit，基本上都是長篇大論的，或是 Facebook/react。 使用工具建立團隊 commit 規範 使用 commitlint 檢查 comit message 搭配 husky 在 pre-commit 階段 lint 程式碼，搭配 eslint（可自由搭配不同 lint 工具）。 在建立 commit message 前就自動執行 commitlint 使用&nbsp;standard version&nbsp;來同時更新版本號和產生 CHANGELOG 檔 這邊會使用 commitlint 官方推薦的規範，或是可以根據官方文件 建立自己的一套規範。 @commitlint/cli&nbsp;是用來執行 commitlint 的工具 @commitlint/config-conventional&nbsp;是根據 conventional commit 所建立的規範，詳細規則可以看這份 source code。 根據官方建議的安裝步驟： 1234npm install -D @commitlint/{cli,config-conventional}// 建立 commitlint.config.js 檔案，並繼承 node_modules 內的 @commitlint/config/config-conventional/index.js 設定檔echo \"module.exports = {extends: ['@commitlint/config-conventional']}\" &gt; commitlint.config.js 可以自己簡單測試一下： 1echo 123 | npm exec commitlint 若是不符合規範，就會顯示錯誤訊息： 補充：npm exec 是 npm v7 推出的功能，可以執行本地依賴或遠端 npm packages 庫內的指令，當執行本地依賴沒有安裝的庫時，會問你要不要安裝，類似 npx，若本來沒有安裝，執行後會自動刪除。 搭配 husky建立 husky 是一款類似於捕捉 git 生命週期的一個工具，使我們可以 git 的每個階段都可以設定一段指令執行。 因此，我們用來在「提交訊息」的時候，使用 commit lint 檢查訊息是否有符合 conventional commit。 安裝 1npm install husky -D 接著執行 husky 的初始化 123npm exec husky install# husky - Git hooks installed 執行完後會出現 .husky 資料夾 接著新增 hook 1npm exec -- husky add .husky/commit-msg 'npm test' 執行後會產生 .husky/commit-msg 的檔案： 藉著我們要把 commit-msg 階段要執行的指令 npm test 更換成 npm exec --no -- commitlint --edit \"\\${1}\" 意思是抓取從 git commit 最後一個提交訊息，用 commitlint 檢查 –edit 意思是會從某個指定檔案讀取最後一個 commit message ，或是到 ./.git/COMMIT_EDITMSG 裡面讀取 接著來隨便 commit 看看，出現錯誤就代表成功啦，因為需要提交符合規範的訊息。 在提交前執行eslint在協作開發的情況下，我們會使用 eslint 來統一 coding style，所以就會希望每個節點都是符合 codeing style。因此我們可以搭配 husky 的 pre-commit hook 來檢查。 建立 pre-commit hook 1npm exec -- husky add .husky/pre-commit 'npm test' 用 eslint 檢查 js, vue 檔案，並指定要忽略 .gitignore 內的檔案。 12345#!/usr/bin/env sh. \"$(dirname -- \"$0\")/_/husky.sh\"eslint --ext \\\".js,.vue\\\" --ignore-path .gitignore .\", 但光是這樣還不夠，現在這樣只要做提交，eslint 就會去會檢查所有的檔案，若專案檔案一大，每次都要跑很久。 所以我們只需要檢查 git 有偵測到變更的檔案就好了。 修改為： 12345#!/usr/bin/env sh. \"$(dirname -- \"$0\")/_/husky.sh\"npm run eslint $(git diff --diff-filter=ACM --name-only HEAD | grep -E '\\.(js|vue)$') --ignore-path .gitignore .eslintignore git diff –name-only HEAD :列出與目前分支有變更的檔案名稱 -diff-filter=ACM 過濾出 Add, Copy, Modified 檔案，排除 Delete grep -E ‘.(js|vue)$’ 過濾出 js 檔 &amp; vue 檔 忽略 ignore-path 指定「忽略文件」的位置 Standard Version 更新版本號、產生 change log standard 是一套幫你自動化產生 changelog 跟更新版本號的工具，簡單來說會分為以下步驟： 抓取上一個版本之前的 fix, feat 類型的提交訊息 貼入 CHANGELOG.md 檔案中 更新 package.json 的版本 自動 commit 安裝 1npm install -D standard-version package.json`` 123\"scripts\": { \"release\": \"standard-version\"}, 執行 npm run release 就會發現它自動幫你產生了 CHANGELOG.md 檔案（上圖），並把你提交內 type 為 feat &amp; fix 的變更抓進來，換句話說 refactor, build, chore 都不會被抓進來，這用來發布更新文件，真的非常方便！ 另外看 git 的線圖，也可以看到他幫我自動做了提交，也把 package.json 的 version 更新為新版號。 結語上面我們透過工具 commit + husky + lint library + standard version，可以建立完整的提交流程：阻擋不符合規範的提交，並透過 pre-commit hook 檢查 coding style，最後再自動戶產生 changelog 與更新版本號。 具有語意化的提交訊息，與詳細的描述，對我而言目前只有優點沒有缺點，但並不是要我們每個提交都需要長篇大論，可以根據狀況做調整，最適合你的方式就是最好的。 另外也有 Commitizen/cz-cli 自動化提交工具，在你提交的時候問你一些問題，有些是選擇題，互動的方式，幫你自動產生提交，你只要回答他問你的問題就夠了；也可以參考 Git Emoji，設定屬於自己的 Emoji 提交，非常有趣，有興趣可以上去看看。 最後，我想就算是自己一個人的專案，設定可讀性高的提交，未來在回顧 git 紀錄的時候，也是一個提高檢視效率的方法，所以開始讓提交的可讀性變高吧，Why not ? 參考文章 知乎 - 如何写好 Git commit log? 优雅的提交你的 Git Commit Message 5 Useful Tips For A Better Commit Message pjchender - 透過工具建立有規範的 git commit message 吧","link":"/blog.rock070/2022/06/10/git-commit/"}],"tags":[],"categories":[{"name":"data structure","slug":"data-structure","link":"/blog.rock070/categories/data-structure/"},{"name":"algorithms","slug":"algorithms","link":"/blog.rock070/categories/algorithms/"},{"name":"CSS","slug":"CSS","link":"/blog.rock070/categories/CSS/"},{"name":"Git","slug":"Git","link":"/blog.rock070/categories/Git/"}]}